import os
from utils.logger_config import get_logger
from services.base_service import BaseContentService 
from utils.dynamodb_helper import DynamoDBHelper
from utils.s3_helper import S3Helper # To save images
from utils.errors import ServiceError 
from agents.image_gen_openai import generate_image_from_prompt as generate_openai_image
import utils.constants as Constants

logger = get_logger(__name__)
SERVICE_NAME = "ImageGenService"

class ImageGenService(BaseContentService): 
    """Orchestrates the image generation process."""

    def __init__(self):
        super().__init__(service_name=SERVICE_NAME) 

    # --- Implement Abstract Properties ---
    @property
    def status_prefix(self) -> str:
        return "IMAGE_GEN"

    @property
    def output_uri_db_key(self) -> str:
        # This service outputs a list of URIs to DynamoDB
        return Constants.IMAGE_URIS 

    # --- Implement Abstract Methods ---

    def _select_agent(self, website_settings: dict, post_item: dict | None = None, previous_step_output: any = None) -> callable:
        """Selects the image generation agent."""
        logger.info(f"[{self.service_name}] Selecting OpenAI DALL-E agent for image generation.")
        return generate_openai_image

    def _call_agent(self, agent_function: callable, post_item: dict, website_settings: dict, previous_step_output: dict) -> any:
        """
        Calls the image generation agent for each prompt found in the post item.
        Returns a list of generated image URLs (from the agent).
        """
        
        image_prompts = post_item.get(Constants.IMAGE_PROMPTS) 
        if not image_prompts or not isinstance(image_prompts, list):
             post_id = post_item.get(Constants.POST_ID, "Unknown")
             logger.error(f"Missing or invalid '{Constants.IMAGE_PROMPTS}' (list) in fetched post item for postId '{post_id}'.")
             raise ServiceError(f"Required '{Constants.IMAGE_PROMPTS}' not found for postId '{post_id}'. Has the image prompt step completed successfully?", 400, service_name=self.service_name)
            
        generated_image_urls = []
        for i, prompt in enumerate(image_prompts):
            logger.info(f"[{self.service_name}] Requesting image {i+1}/{len(image_prompts)} for prompt: '{prompt[:80]}...'")
            try:
                # Call agent for each prompt
                image_url = agent_function(
                    prompt=prompt,
                    website_settings=website_settings 
                )
                if image_url:
                    generated_image_urls.append(image_url)
                else:
                    logger.warning(f"[{self.service_name}] Agent returned no URL for prompt index {i}. Skipping.")
                    # Decide if this should be a partial failure or continue
            except Exception as e:
                 # Log error for this specific prompt but try to continue with others
                 logger.exception(f"[{self.service_name}] Failed to generate image for prompt index {i}: '{prompt[:80]}...'. Error: {e}")
                 # Optionally collect errors to report later

        if not generated_image_urls:
             raise ServiceError("No images were successfully generated by the agent.", 500, service_name=self.service_name)

        logger.info(f"[{self.service_name}] Agent generation complete. Got {len(generated_image_urls)} image URLs.")
        # Return the list of URLs obtained from the agent
        return generated_image_urls


    def _save_agent_output(self, website_id: str, post_id: str, agent_output: any) -> str | None:
        """
        Downloads images from URLs returned by the agent and saves them to S3.
        Returns a placeholder string indicating success, as the final URIs are saved to DynamoDB.
        """
        if not isinstance(agent_output, list):
             logger.error(f"[{self.service_name}] Agent output was not a list of URLs, cannot save images.")
             return None # Indicate failure

        image_s3_uris = []
        for i, image_url in enumerate(agent_output): # agent_output is the list of URLs
             logger.info(f"[{self.service_name}] Processing image URL {i+1}: {image_url}")
             s3_uri = self.s3_helper.download_and_save_image(
                 image_url=image_url,
                 website_id=website_id,
                 post_id=post_id,
                 image_index=i # Pass index for filename uniqueness
             )
             if s3_uri:
                 image_s3_uris.append(s3_uri)
             else:
                 logger.warning(f"[{self.service_name}] Failed to download/save image from URL: {image_url}. Skipping.")
                 # Decide on failure strategy - stop all, or just skip this one?

        if not image_s3_uris:
             logger.error(f"[{self.service_name}] Failed to save any images to S3 for postId {post_id}.")
             return None # Indicate failure

        logger.info(f"[{self.service_name}] Successfully saved {len(image_s3_uris)} images to S3 for postId {post_id}.")
        
        # --- Save the LIST of S3 URIs to DynamoDB ---
        update_success = self.db_helper.update_post_item(post_id, {Constants.IMAGE_URIS: image_s3_uris})
        if not update_success:
             logger.error(f"[{self.service_name}] Saved images to S3, but failed to update IMAGE_URIS in DynamoDB for postId {post_id}.")
             return None # Indicate failure to update DB

        logger.info(f"[{self.service_name}] Image S3 URIs successfully saved to DynamoDB for postId {post_id}.")
        # Return placeholder string to signal overall success for this step
        return "S3_And_DynamoDB_Updated"


    # --- Override Base Class DB Update Method ---
    def _update_db_uri(self, post_id: str, save_output_result: str | None):
        """Overrides the base method because image URIs list is saved directly in the item during _save_agent_output."""
        if save_output_result == "S3_And_DynamoDB_Updated":
             logger.info(f"[{self.service_name}] Image URIs list already saved to DynamoDB item for postId {post_id}. Skipping standard URI update.")
        else:
             logger.error(f"[{self.service_name}] _save_agent_output did not indicate successful S3/DynamoDB update for postId {post_id}.")
        return save_output_result == "S3_And_DynamoDB_Updated"